{"id":"../node_modules/seethru/src/seeThru.js","dependencies":[{"name":"/Users/ftinoco/Sites/klic-takeover-maker/package.json","includedInParent":true,"mtime":1540414549000},{"name":"/Users/ftinoco/Sites/klic-takeover-maker/.babelrc","includedInParent":true,"mtime":1540394815000},{"name":"/Users/ftinoco/Sites/klic-takeover-maker/node_modules/seethru/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"var define;\n/**\n* jQuery seeThru - transparent HTML5 video - written by Frederik Ring (frederik.ring@gmail.com)\n* based on http://jakearchibald.com/scratch/alphavid/ by Jake Archibald (jaffathecake@gmail.com)\n\n* Copyright (c) 2017 Frederik Ring\n* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n* see https://github.com/m90/seeThru for documentation\n*/\n\n(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot.seeThru = factory();\n\t}\n})(this, function () {\n\tvar canConstructEvents = (function () {\n\t\ttry {\n\t\t\tif (new Event('submit', { bubbles: false }).bubbles !== false) {\n\t\t\t\treturn false;\n\t\t\t} else if (new Event('submit', { bubbles: true }).bubbles !== true) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t})();\n\n\tvar eventsToEcho = [\n\t\t'mouseenter',\n\t\t'mouseleave',\n\t\t'click',\n\t\t'mousedown',\n\t\t'mouseup',\n\t\t'mousemove',\n\t\t'mouseover',\n\t\t'hover',\n\t\t'dblclick',\n\t\t'contextmenu',\n\t\t'focus',\n\t\t'blur'\n\t];\n\n\t/**\n\t* convert an image's alpha channel into a black & white canvasPixelArray\n\t* @param {DOMElement} maskObj\n\t* @param {Object} dimensions\n\t* @returns {CanvasPixelArray} RGBA\n\t*/\n\tfunction convertAlphaMask (maskObj, dimensions) {\n\t\tvar convertCanvas = document.createElement('canvas');\n\t\tvar convertCtx = convertCanvas.getContext('2d');\n\t\tvar RGBA;\n\n\t\tconvertCanvas.width = dimensions.width;\n\t\tconvertCanvas.height = dimensions.height;\n\t\tconvertCtx.drawImage(maskObj, 0, 0, dimensions.width, dimensions.height);\n\n\t\tRGBA = convertCtx.getImageData(0, 0, dimensions.width, dimensions.height);\n\n\t\t//alpha data is on each 4th position -> [0+(4*n)] => R, [1+(4*n)] => G, [2+(4*n)] => B, [3+(4*n)] => A\n\t\tfor (var i = 3, len = RGBA.data.length; i < len; i = i + 4) {\n\t\t\tRGBA.data[i - 1] = RGBA.data[i - 2] = RGBA.data[i - 3] = RGBA.data[i]; //alpha into RGB\n\t\t\tRGBA.data[i] = 255; //alpha is always 100% opaque\n\t\t}\n\n\t\treturn RGBA;\n\t}\n\n\t/**\n\t* unmultiply an image with alpha information\n\t* @param {Array} rgb - canvasPixelArray representing the image to be unmultiplied\n\t* @param {Array} alphaData - canvasPixelArray representing the alpha to use\n\t* @returns {Array} rgb\n\t*/\n\tfunction unmultiply (rgb, alphaData) {\n\t\tfor (var i = 3, len = rgb.data.length; i < len; i = i + 4) {\n\t\t\trgb.data[i] = alphaData[i - 1]; //copy B value into A channel\n\t\t\trgb.data[i - 3] = rgb.data[i - 3] / (alphaData[i - 1] ? (alphaData[i - 1] / 255) : 1); //un-premultiply B\n\t\t\trgb.data[i - 2] = rgb.data[i - 2] / (alphaData[i - 1] ? (alphaData[i - 1] / 255) : 1); //un-premultiply G\n\t\t\trgb.data[i - 1] = rgb.data[i - 1] / (alphaData[i - 1] ? (alphaData[i - 1] / 255) : 1); //un-premultiply R\n\t\t}\n\t\treturn rgb;\n\t}\n\n\t/**\n\t* gets a prefixed rAF version or a polyfill to use if window.requestAnimationFrame is not available\n\t* @returns {Function}\n\t*/\n\tfunction getRequestAnimationFrame () {\n\t\tvar lastTime = 0;\n\t\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\n\t\tfor (var x = 0; x < vendors.length; x++) {\n\t\t\tif (window[vendors[x] + 'RequestAnimationFrame']) { return window[vendors[x] + 'RequestAnimationFrame']; }\n\t\t}\n\n\t\treturn function (callback) {\n\t\t\tvar currTime = new Date().getTime();\n\t\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\tvar id = window.setTimeout(function () {\n\t\t\t\tcallback(currTime + timeToCall);\n\t\t\t}, timeToCall);\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\t\t};\n\t}\n\n\t/**\n\t* gets a prefixed cAF version or a polyfill to use if window.cancelAnimationFrame is not available\n\t* @returns {Function}\n\t*/\n\tfunction getCancelAnimationFrame () {\n\t\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\n\t\tfor (var x = 0; x < vendors.length; x++) {\n\t\t\tif (window[vendors[x] + 'CancelAnimationFrame']) { return window[vendors[x] + 'CancelAnimationFrame']; }\n\t\t\tif (window[vendors[x] + 'CancelRequestAnimationFrame']) { return window[vendors[x] + 'CancelRequestAnimationFrame']; }\n\t\t}\n\n\t\treturn function (id) { clearTimeout(id); };\n\t}\n\n\t/**\n\t* turn array like object into real array\n\t* @param {Object} el\n\t* @returns {Array}\n\t*/\n\tfunction slice (el) {\n\t\treturn [].slice.call(el);\n\t}\n\n\t/**\n\t* check [[Class]] by calling {}.toString on any object\n\t* @param {Object} el\n\t* @returns {String}\n\t*/\n\tfunction toString (el) {\n\t\treturn Object.prototype.toString.call(el);\n\t}\n\n\t/**\n\t* insert a DOM Node after another\n\t* @param {DOMElement} node\n\t* @param {DOMElement} after\n\t*/\n\tfunction insertAfter (node, after) {\n\t\tif (after.nextSibling) {\n\t\t\tafter.parentNode.insertBefore(node, after.nextSibling);\n\t\t} else {\n\t\t\tafter.parentNode.appendChild(node);\n\t\t}\n\t}\n\n\t/**\n\t* return a DOM Node matching variable input\n\t* input might be a DOMElement, a DOMCollection or a string\n\t* @param input\n\t* @returns DOMElement\n\t*/\n\tfunction getNode (input) {\n\t\tif (input.tagName) {\n\t\t\treturn input;\n\t\t} else if (toString(input) === '[object String]') {\n\t\t\treturn document.querySelector(input);\n\t\t} else if (input.length) {\n\t\t\treturn input[0];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t* serialize an object into a string of CSS to use for style.cssText\n\t* @param {Object} obj\n\t* @returns {String}\n\t*/\n\tfunction cssObjectToString (obj) {\n\t\tvar res = [];\n\t\tfor (var prop in obj) {\n\t\t\tif (obj.hasOwnProperty(prop)) {\n\t\t\t\tres.push(prop + ': ' + obj[prop] + ';');\n\t\t\t}\n\t\t}\n\t\treturn res.join('');\n\t}\n\n\t/**\n\t* make the script available as a plugin on the passed jQuery instance\n\t* @param {jQuery} $\n\t*/\n\tfunction attachSelfAsPlugin ($) {\n\t\tif (!$.fn || $.fn.seeThru) { return; }\n\n\t\t$.fn.seeThru = function () {\n\t\t\tvar args = slice(arguments);\n\t\t\tvar head = args.shift();\n\t\t\treturn this.each(function () {\n\t\t\t\tvar self = this;\n\t\t\t\tvar $this = $(this);\n\t\t\t\tif (args.length === 0) {\n\t\t\t\t\tif ($this.data('seeThru')) { return; }\n\t\t\t\t\t$this.data('seeThru', new SeeThru(this, head)._init());\n\t\t\t\t} else if (toString(head) === '[object String]') {\n\t\t\t\t\tif (!$this.data('seeThru')) { return; }\n\t\t\t\t\t// all methods other then init will be deferred until `.ready()`\n\t\t\t\t\t$this.data('seeThru').ready(function () {\n\t\t\t\t\t\t$this.data('seeThru')[head].apply(self, args);\n\t\t\t\t\t\tif (head === 'revert') {\n\t\t\t\t\t\t\t$this.data('seeThru', null);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t* @constructor Store\n\t* simple wrapper around [] to keep track of video elements that are currently\n\t* handled by the script\n\t*/\n\tfunction Store () {\n\t\tvar elements = [];\n\t\tthis.push = function (el) {\n\t\t\tif (el) {\n\t\t\t\telements.push(el);\n\t\t\t\treturn el;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t\tthis.has = function (el) {\n\t\t\treturn elements.some(function (video) {\n\t\t\t\treturn video === el;\n\t\t\t});\n\t\t};\n\t\tthis.remove = function (el) {\n\t\t\telements = elements.filter(function (video) {\n\t\t\t\treturn video !== el;\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t* @constructor TransparentVideo\n\t* handles the transformation of a video into the canvas elements and keeps track\n\t* of intervals and animation loop logic\n\t* @param {DOMElement} video\n\t* @param {Object options}\n\t*/\n\tfunction TransparentVideo (video, options) {\n\t\tvar initialStyles = {};\n\t\tvar divisor = options.mask ? 1 : 2; //static alpha data will not cut the image dimensions\n\t\tvar dimensions = { // calculate dimensions\n\t\t\twidth: parseInt(options.width, 10),\n\t\t\theight: parseInt(options.height, 10)\n\t\t};\n\t\tvar bufferCanvas = document.createElement('canvas');\n\t\tvar buffer = bufferCanvas.getContext('2d');\n\t\tvar displayCanvas = document.createElement('canvas');\n\t\tvar display = displayCanvas.getContext('2d');\n\t\tvar posterframe;\n\t\tvar interval;\n\t\tvar requestAnimationFrame = window.requestAnimationFrame || getRequestAnimationFrame();\n\t\tvar cancelAnimationFrame = window.cancelAnimationFrame || getCancelAnimationFrame();\n\t\tvar lastDrawnFrameTime = null;\n\t\tvar drawFrame = function (recurse) {\n\t\t\tvar image, alphaData, i, len, currentFrameTime = video.currentTime;\n\n\t\t\tif (lastDrawnFrameTime !== currentFrameTime && video.readyState > 1) {\n\t\t\t\tlastDrawnFrameTime = currentFrameTime;\n\n\t\t\t\tbuffer.drawImage(video, 0, 0, dimensions.width, dimensions.height * divisor); //scales if <video>-dimensions are not matching\n\t\t\t\timage = buffer.getImageData(0, 0, dimensions.width, dimensions.height);\n\t\t\t\talphaData = buffer.getImageData(0, dimensions.height, dimensions.width, dimensions.height).data; //grab from video;\n\n\t\t\t\tif (options.unmult) unmultiply(image, alphaData);\n\n\t\t\t\t//calculate luminance from buffer part, no weighting needed when alpha mask is used\n\t\t\t\tfor (i = 3, len = image.data.length; i < len; i = i + 4) {\n\t\t\t\t\timage.data[i] = options.alphaMask ? alphaData[i - 1] : Math.max(alphaData[i - 1], alphaData[i - 2], alphaData[i - 3]);\n\t\t\t\t}\n\n\t\t\t\tdisplay.putImageData(image, 0, 0, 0, 0, dimensions.width, dimensions.height);\n\t\t\t}\n\n\t\t\tif (recurse) {\n\t\t\t\tinterval = requestAnimationFrame(function () {\n\t\t\t\t\tdrawFrame(true);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tvar drawStaticMask = function (node) {\n\t\t\tif (node.tagName !== 'IMG') throw new Error('Cannot use non-image element as mask!');\n\n\t\t\tnode.width = dimensions.width;\n\t\t\tnode.height = dimensions.height; //adjust image dimensions to video dimensions\n\n\t\t\tif (options.alphaMask) { //alpha channel has to be converted into RGB\n\t\t\t\tbuffer.putImageData(convertAlphaMask(node, dimensions), 0, dimensions.height);\n\t\t\t} else { //no conversion needed, draw image into buffer\n\t\t\t\tbuffer.drawImage(node, 0, dimensions.height, dimensions.width, dimensions.height);\n\t\t\t}\n\n\t\t\tnode.style.display = 'none';\n\t\t};\n\n\n\t\t/**\n\t\t* @method startRendering\n\t\t* kick off the animation loop\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tthis.startRendering = function () {\n\t\t\tdrawFrame(true);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* @method stopRendering\n\t\t* ends the animation loop\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tthis.stopRendering = function () {\n\t\t\tcancelAnimationFrame(interval);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* @method stopRendering\n\t\t* ends the animation loop, removes the canvas elements and unhides the video\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tthis.teardown = function () {\n\t\t\tcancelAnimationFrame(interval);\n\t\t\tvideo.parentNode.removeChild(video.nextSibling);\n\t\t\tvideo.parentNode.removeChild(video.nextSibling);\n\t\t\tfor (var key in initialStyles) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(initialStyles, key)) {\n\t\t\t\t\tvideo.style[key] = initialStyles[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* @method updateMask\n\t\t* draws a new image onto the alpha portion of the buffer\n\t\t* @param {DOMElement} node\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tthis.updateMask = function (node) {\n\t\t\tdrawStaticMask(node);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* @method getCanvas\n\t\t* gets the visible canvas element that is used for display\n\t\t* @returns {DOMElement}\n\t\t* @API public\n\t\t*/\n\t\tthis.getCanvas = function () {\n\t\t\treturn displayCanvas;\n\t\t};\n\n\t\t/**\n\t\t* @method getPoster\n\t\t* gets the posterframe element\n\t\t* @returns {DOMElement}\n\t\t* @API public\n\t\t*/\n\t\tthis.getPoster = function () {\n\t\t\treturn posterframe;\n\t\t};\n\n\t\tvar elementDimensions = video.getBoundingClientRect();\n\n\t\tif (!dimensions.height || !dimensions.width) { //we need to find out at least one dimension parameter as it is not explicitly set\n\t\t\tif (!video.width && !video.height) { //<video> has no width- or height-attribute -> source dimensions from video source meta\n\t\t\t\tdimensions.width = dimensions.width || video.videoWidth;\n\t\t\t\tdimensions.height = dimensions.height || video.videoHeight / divisor;\n\t\t\t} else if (!video.height) { //<video> has no height-attribute -> source dimensions from video source meta\n\t\t\t\tdimensions.width = dimensions.width || elementDimensions.width;\n\t\t\t\tdimensions.height = dimensions.height || elementDimensions.width / (video.videoWidth / Math.floor(video.videoHeight / divisor));\n\t\t\t} else if (!video.width) { //<video> has no height-attribute -> source dimensions from video source meta\n\t\t\t\tdimensions.width = dimensions.width || elementDimensions.height * (video.videoWidth / Math.floor(video.videoHeight / divisor));\n\t\t\t\tdimensions.height = dimensions.height || elementDimensions.height;\n\t\t\t} else { //get values from height and width attributes of <video>\n\t\t\t\tdimensions.width = dimensions.width || elementDimensions.width;\n\t\t\t\tdimensions.height = dimensions.height || elementDimensions.height / divisor;\n\t\t\t}\n\t\t}\n\n\t\tbufferCanvas.width = dimensions.width;\n\t\tbufferCanvas.height = dimensions.height * 2;\n\t\tbufferCanvas.style.display = 'none';\n\t\tbufferCanvas.className = options.namespace + '-buffer';\n\n\t\tdisplayCanvas.width = dimensions.width;\n\t\tdisplayCanvas.height = dimensions.height;\n\t\tdisplayCanvas.className = options.namespace + '-display';\n\n\t\tinsertAfter(bufferCanvas, video);\n\t\tinsertAfter(displayCanvas, video);\n\n\t\t// draw static mask if needed\n\t\tif (options.mask) {\n\t\t\tdrawStaticMask(getNode(options.mask));\n\t\t}\n\n\t\t// append \"posterframe\" if option is set and attribute is present on the video\n\t\tif (options.poster && video.poster) {\n\t\t\tposterframe = document.createElement('div');\n\t\t\tposterframe.className = 'seeThru-poster';\n\t\t\tposterframe.style.cssText = cssObjectToString({\n\t\t\t\twidth: dimensions.width + 'px',\n\t\t\t\theight: dimensions.height + 'px',\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\t'background-size': 'cover',\n\t\t\t\t'background-position': 'center',\n\t\t\t\t'background-image': 'url(\"' + video.poster + '\")'\n\t\t\t});\n\t\t\tinsertAfter(posterframe, video);\n\t\t}\n\n\t\tfor (var key in options.videoStyles) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(options.videoStyles, key)) {\n\t\t\t\tinitialStyles[key] = window.getComputedStyle(video)[key];\n\t\t\t\tvideo.style[key] = options.videoStyles[key];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @constructor SeeThru\n\t* handles a video element turned into a transparent mock version of itself\n\t* @param {String|DOMElement|DOMNode} DOMNode\n\t* @param {Object} [options]\n\t*/\n\tfunction SeeThru (DOMNode, options) {\n\n\t\tvar self = this;\n\t\tvar ready = false;\n\t\tvar callbacks = [];\n\t\tvar defaultOptions = {\n\t\t\tstart: 'external', // 'clicktoplay' or 'external' defaults to external\n\t\t\tend: 'stop', // 'loop', 'rewind', 'stop' any other input will default to 'stop'\n\t\t\tmask: false, // this lets you define a <img> (selected by #id or .class - class will use the first occurence)used as a black and white mask instead of adding the alpha to the video\n\t\t\talphaMask: false, // defines if the used `mask` uses black and white or alpha information - defaults to false, i.e. black and white\n\t\t\twidth: null, // lets you specify a pixel value used as width -- overrides all other calculations\n\t\t\theight: null, // lets you specify a pixel value used as height -- overrides all other calculations\n\t\t\tposter: false, // the plugin will display the image set in the video's poster-attribute when not playing if set to true\n\t\t\tunmult: false, // set this to true if your video material is premultiplied on black - might cause performance issues\n\t\t\tvideoStyles: { display: 'none' }, // this is the CSS that is used to hide the original video - can be updated in order to work around autoplay restrictions\n\t\t\tnamespace: 'seeThru' // this will be used for prefixing the CSS classnames applied to the created elements\n\t\t};\n\n\t\toptions = options || {};\n\t\tself._video = getNode(DOMNode);\n\n\t\tif (!self._video || self._video.tagName !== 'VIDEO') throw new Error('Could not use specified source');\n\n\t\tself._options = (function (options) {\n\t\t\tfor (var key in defaultOptions) {\n\t\t\t\tif (defaultOptions.hasOwnProperty(key)) {\n\t\t\t\t\tif (!(key in options)) {\n\t\t\t\t\t\toptions[key] = defaultOptions[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t})(options);\n\n\t\t/**\n\t\t* @method init\n\t\t* sets up transparent video once the video has metadata\n\t\t* @returns self\n\t\t* @API private\n\t\t*/\n\t\tself._init = function () {\n\t\t\tfunction runInit () {\n\t\t\t\tfunction playSelfAndUnbind () {\n\t\t\t\t\tself._video.play();\n\t\t\t\t\tif (self._options.poster) {\n\t\t\t\t\t\tself._seeThru.getPoster().removeEventListener('click', playSelfAndUnbind);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._seeThru.getCanvas().removeEventListener('click', playSelfAndUnbind);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (elementStore.has(self._video)) { throw new Error('seeThru already initialized on passed video element!'); }\n\n\t\t\t\tself._seeThru = new TransparentVideo(self._video, self._options);\n\n\t\t\t\t// attach behavior for start options\n\t\t\t\tif (self._options.start === 'clicktoplay') {\n\t\t\t\t\tif (self._options.poster) {\n\t\t\t\t\t\tself._seeThru.getPoster().addEventListener('click', playSelfAndUnbind);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._seeThru.getCanvas().addEventListener('click', playSelfAndUnbind);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// attach behavior for end options\n\t\t\t\tif (self._options.end === 'rewind') {\n\t\t\t\t\tself._video.addEventListener('ended', function () {\n\t\t\t\t\t\tself._video.currentTime = 0;\n\t\t\t\t\t\tself._seeThru.getCanvas().addEventListener('click', playSelfAndUnbind);\n\t\t\t\t\t});\n\t\t\t\t} else if (self._options.end !== 'stop') {\n\t\t\t\t\tself._video.addEventListener('ended', function () {\n\t\t\t\t\t\tself._video.currentTime = 0;\n\t\t\t\t\t\tself._video.play();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// attach behavior for posterframe option\n\t\t\t\tif (self._options.poster && self._video.poster) {\n\t\t\t\t\tself._video.addEventListener('play', function () {\n\t\t\t\t\t\tself._seeThru.getPoster().style.display = 'none';\n\t\t\t\t\t});\n\t\t\t\t\tself._video.addEventListener('pause', function () {\n\t\t\t\t\t\tself._seeThru.getPoster().style.display = 'block';\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// some events that are registered on the canvas representation\n\t\t\t\t// will be echoed on the original video element so that pre-existing\n\t\t\t\t// event handlers bound to the video element will keep working\n\t\t\t\t// it is recommended to use `.getCanvas()` to bind new behavior though\n\t\t\t\teventsToEcho.forEach(function (eventName) {\n\t\t\t\t\tself._seeThru.getCanvas().addEventListener(eventName, function () {\n\t\t\t\t\t\tvar evt;\n\t\t\t\t\t\tif (canConstructEvents) {\n\t\t\t\t\t\t\tevt = new Event(eventName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tevt = document.createEvent('Event');\n\t\t\t\t\t\t\tevt.initEvent(eventName, true, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself._video.dispatchEvent(evt);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tself._seeThru.startRendering();\n\n\t\t\t\tready = true;\n\n\t\t\t\telementStore.push(self._video);\n\n\t\t\t\tcallbacks.forEach(function (cb) {\n\t\t\t\t\tcb(self, self._video, self.getCanvas());\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (self._video.readyState > 0) {\n\t\t\t\trunInit();\n\t\t\t} else {\n\t\t\t\tself._video.addEventListener('loadedmetadata', runInit);\n\t\t\t}\n\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* @method getCanvas\n\t\t* returns the canvas element that is used for on-screen displaylay\n\t\t* @returns {DOMElement}\n\t\t* @API public\n\t\t*/\n\t\tself.getCanvas = function () {\n\t\t\treturn self._seeThru.getCanvas();\n\t\t};\n\n\t\t/**\n\t\t* @method play\n\t\t* starts playback of the associated video element\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tself.play = function () {\n\t\t\tself._video.play();\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* @method pause\n\t\t* halts playback of the associated video element\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tself.pause = function () {\n\t\t\tself._video.pause();\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* @method revert\n\t\t* reverts the transparent video back to its original state\n\t\t* @API public\n\t\t*/\n\t\tself.revert = function () {\n\t\t\tself._seeThru.teardown();\n\t\t\telementStore.remove(self._video);\n\t\t};\n\n\t\t/**\n\t\t* @method updateMask\n\t\t* @param {String|DOMElement|DOMCollection} mask\n\t\t* swaps the static mask currently used for sourcing alpha\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tself.updateMask = function (mask) {\n\t\t\tself._seeThru.updateMask(getNode(mask));\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* @method ready\n\t\t* @param {Function} cb\n\t\t* defers the passed callback until the associated video element has metadata\n\t\t* passes itself as the 1st argument of the callback\n\t\t* @returns self\n\t\t* @API public\n\t\t*/\n\t\tself.ready = function (cb) {\n\t\t\tif (ready) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tcb(self, self._video, self.getCanvas());\n\t\t\t\t}, 0);\n\t\t\t} else {\n\t\t\t\tcallbacks.push(cb);\n\t\t\t}\n\t\t\treturn self;\n\t\t};\n\n\t}\n\n\t// if we have a global version of jQuery we'll automatically attach the script as a plugin\n\tif (window.jQuery) {\n\t\tattachSelfAsPlugin(window.jQuery);\n\t}\n\n\tvar elementStore = new Store();\n\n\treturn {\n\t\tcreate: function (DOMCollection, options) {\n\t\t\treturn new SeeThru(DOMCollection, options)._init();\n\t\t},\n\t\tattach: attachSelfAsPlugin\n\t};\n\n});\n","map":null},"hash":"f3a3be80691ab8ea609ab70e3d08767c","cacheData":{"env":{}}}